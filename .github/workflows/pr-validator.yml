name: PR Validator

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# WHY pull_request_target?
#   PRs from forks run in an isolated context. The default pull_request trigger
#   gives the token READ-ONLY permissions for security. pull_request_target runs
#   in the context of the BASE branch (your repo), so GITHUB_TOKEN retains
#   write access to labels, comments, and issues â€” even for fork PRs.
#
# WHY THIS STILL FAILED:
#   pull_request_target is correct, but two things can still kill it:
#   1. The workflow file was not yet on the DEFAULT branch when the PR arrived.
#      GitHub evaluates permissions from the base branch's workflow file.
#      Fix: merge this file to main/master BEFORE testing with any PR.
#   2. Repo or Org settings â†’ Actions â†’ "Fork pull request workflows from
#      outside collaborators" is set to "Require approval for all outside
#      collaborators". An admin must approve the first run from each new fork.
#      Fix: set it to "Require approval for first-time contributors" instead.
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
on:
  pull_request_target:
    types: [opened, edited, reopened, synchronize]

# permissions block below is kept for documentation only.
# With PAT_TOKEN the effective permissions come from the PAT itself,
# not from this block. The PAT must have Issues=write + Pull requests=write.
permissions:
  pull-requests: write
  issues: write
  contents: read

jobs:
  validate-pr:
    runs-on: ubuntu-latest
    steps:
      - name: Validate PR Description
        uses: actions/github-script@v7
        with:
          # Using PAT_TOKEN instead of GITHUB_TOKEN because the gdg-charusat
          # org-level Actions settings strip write permissions from GITHUB_TOKEN
          # on fork PRs even when pull_request_target is used.
          # PAT_TOKEN is a Fine-grained PAT stored as a repo secret with
          # Issues=write and Pull requests=write on Zaplink_frontend only.
          github-token: ${{ secrets.PAT_TOKEN }}
          script: |
            const pr       = context.payload.pull_request;
            const body     = pr.body || '';
            const prNumber = pr.number;
            const author   = pr.user.login;

            // â”€â”€ Label bootstrap â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // createLabel throws 422 if the label already exists â€” that is fine,
            // we catch and ignore it. This is idempotent across every PR run.
            const ensureLabel = async (name, color, description) => {
              try {
                await github.rest.issues.createLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name,
                  color,
                  description
                });
              } catch (_) {}
            };

            await ensureLabel('invalid-pr',        'e11d48', 'PR is missing required information');
            await ensureLabel('needs-review',       '7c3aed', 'Valid issue-linked PR awaiting review');
            await ensureLabel('needs-admin-review', 'f59e0b', 'General improvement PR - admin must assign level');
            await ensureLabel('level-1',            '22c55e', 'Beginner contribution (5 pts)');
            await ensureLabel('level-2',            'f97316', 'Intermediate contribution (20 pts)');

            // â”€â”€ Auto-assign reviewer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // Silently skips if already assigned or if author IS the reviewer.
            try {
              const REVIEWER = 'krishnapaljadeja';
              if (author !== REVIEWER) {
                await github.rest.pulls.requestReviewers({
                  owner:       context.repo.owner,
                  repo:        context.repo.repo,
                  pull_number: prNumber,
                  reviewers:   [REVIEWER]
                });
              }
            } catch (_) { /* already assigned or user not found â€” ignore */ }

            // â”€â”€ Clean slate: strip all status labels before re-evaluating â”€â”€â”€â”€
            // removeLabel throws 404 if the label isn't on the PR â€” catch it.
            const removeLabel = async (label) => {
              try {
                await github.rest.issues.removeLabel({
                  owner:        context.repo.owner,
                  repo:         context.repo.repo,
                  issue_number: prNumber,
                  name:         label
                });
              } catch (_) {}
            };

            await removeLabel('invalid-pr');
            await removeLabel('needs-review');
            await removeLabel('needs-admin-review');

            // â”€â”€ Duplicate comment guard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // On 'edited' events this job re-runs. Without this guard a new
            // bot comment is posted every time the author edits the description,
            // flooding the PR thread. We check existing comments and skip
            // posting if the latest bot comment already matches the outcome.
            const BOT_TAG_INVALID  = '<!-- gdg-bot: invalid-pr -->';
            const BOT_TAG_VALID    = '<!-- gdg-bot: needs-review -->';
            const BOT_TAG_ADMIN    = '<!-- gdg-bot: needs-admin-review -->';

            const existingComments = await github.rest.issues.listComments({
              owner:        context.repo.owner,
              repo:         context.repo.repo,
              issue_number: prNumber,
              per_page:     100
            });

            // Find the most recent comment left by this bot
            const botComments = existingComments.data
              .filter(c =>
                c.user.type === 'Bot' &&
                (c.body.includes(BOT_TAG_INVALID) ||
                 c.body.includes(BOT_TAG_VALID)   ||
                 c.body.includes(BOT_TAG_ADMIN))
              );
            const lastBotComment = botComments[botComments.length - 1];

            // â”€â”€ Parse PR body â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const teamMatch      = body.match(/team\s*\d+/i);
            const hasTeamNumber  = Boolean(teamMatch);
            const teamLabel      = hasTeamNumber
                                    ? teamMatch[0].replace(/\s+/g, ' ').trim()
                                    : null;

            const issueMatch     = body.match(/(close[sd]?|fix(e[sd])?|resolve[sd]?)\s*#\d+/i);
            const hasLinkedIssue = Boolean(issueMatch);

            const postComment = async (body) => {
              await github.rest.issues.createComment({
                owner:        context.repo.owner,
                repo:         context.repo.repo,
                issue_number: prNumber,
                body
              });
            };

            const addLabels = async (...labels) => {
              await github.rest.issues.addLabels({
                owner:        context.repo.owner,
                repo:         context.repo.repo,
                issue_number: prNumber,
                labels
              });
            };

            const footer = '\n\n> GDG CHARUSAT Open Source Contri Sprintathon';

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // TYPE 3 â€” No team number â†’ invalid-pr
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (!hasTeamNumber) {
              await addLabels('invalid-pr');

              // Only post a new comment if the last bot comment wasn't already
              // an invalid-pr notice (avoids spam on repeated edits that are
              // still missing the team number).
              if (!lastBotComment || !lastBotComment.body.includes(BOT_TAG_INVALID)) {
                await postComment(
                  `${BOT_TAG_INVALID}\n` +
                  `## âš ï¸ PR Validation Failed\n\n` +
                  `Hey @${author}! Your PR is missing a required field:\n\n` +
                  `**Team Number missing** â€” add your team number anywhere in the PR description.\n` +
                  `Example: \`Team 07\`\n\n` +
                  `**How to fix:**\n` +
                  `1. Click the pencil âœï¸ icon on your PR description\n` +
                  `2. Add your team number (e.g. \`Team 07\`)\n` +
                  `3. Save â€” this check will re-run automatically` +
                  footer
                );
              }
              return;
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // TYPE 1 â€” Team number + linked issue â†’ needs-review
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (hasLinkedIssue) {
              await addLabels('needs-review');

              if (!lastBotComment || !lastBotComment.body.includes(BOT_TAG_VALID)) {
                await postComment(
                  `${BOT_TAG_VALID}\n` +
                  `## âœ… PR Validation Passed\n\n` +
                  `Hey @${author}! Your PR looks good. Here is what we found:\n\n` +
                  `| Field | Value |\n` +
                  `|---|---|\n` +
                  `| **Team Number** | ${teamLabel} |\n` +
                  `| **Linked Issue** | ${issueMatch[0]} |\n\n` +
                  `A maintainer will review your PR within 24â€“48 hours. Stay responsive to feedback!` +
                  footer
                );
              }
              return;
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // TYPE 2 â€” Team number only â†’ needs-admin-review
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            await addLabels('needs-admin-review');

            if (!lastBotComment || !lastBotComment.body.includes(BOT_TAG_ADMIN)) {
              await postComment(
                `${BOT_TAG_ADMIN}\n` +
                `## ðŸ” General Improvement PR â€” Pending Admin Review\n\n` +
                `Hey @${author}! Your PR has been received as a **General Improvement PR** (no linked issue).\n\n` +
                `| Field | Value |\n` +
                `|---|---|\n` +
                `| **Team Number** | ${teamLabel} |\n` +
                `| **Linked Issue** | None |\n\n` +
                `**What happens next:**\n` +
                `1. An admin will review your changes\n` +
                `2. If approved, an admin will add a \`level-1\` or \`level-2\` label based on complexity\n` +
                `3. Points are calculated automatically when the PR is merged\n\n` +
                `> âš ï¸ Trivial or low-quality PRs may be closed without merging.\n` +
                `> Admin review may take longer than standard PRs.` +
                footer
              );
            }
